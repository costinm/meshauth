package webpush

import (
	"bytes"
	"context"
	"crypto/aes"
	"crypto/cipher"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"math/big"
	"net/http"
	"net/http/httputil"
	"os"
	"strconv"
	"strings"
)

// WebpushEncruption is used for encryption and decryption of messages using webpush protocol.
//
// It stores the source and result of encrypting a message and associated parameters.
type WebpushEncryption struct {
	// Full body of the encrypted message, including header (salt, server pub).
	//
	// Format:
	// 16 B Salt
	// 4B rs {0,0, 16, 0} - 4k
	// 1B WorkloadID-Size {65}
	// 65B SendPublicKey
	// Up to 4k encrypted text - with 0x02 appended at the end before encryption
	// Wasted: 7 const.
	// Overhead: 16 salt, 16 sig, 64 pub. Total: 103 (64+32+7)
	Ciphertext []byte

	// 16B For encryption: must be a random generated by sender.
	Salt []byte

	// UA Public bytes - from subscription, it's the public key of the
	// receiver ( user agent, browser ).
	UAPublic []byte

	// Only used for encrypt - the private key of the sender
	SendPrivate []byte

	// Temp EC key for encryption, 65B
	SendPublic []byte

	// Only used for decrypt
	UAPrivate []byte

	// Auth - from subscription. If missing, a default value can be used - either zero or
	// a hash of the recipinent URL or public key.
	Auth []byte

	// Computed from public/private
	ecdh_secret []byte
}

const (
	maxPayloadLength = 4078
)

var (
	authInfo = []byte("Content-Encoding: auth\x00")
	curve    = elliptic.P256()

	// Generate a random EC256 key pair. Overridable for testing.
	// Returns priv as a 16-byte point, and pub in uncompressed format, 33 bytes.
	randomKey = func() (priv []byte, pub []byte, err error) {
		priv, x, y, err := elliptic.GenerateKey(curve, rand.Reader)
		if err != nil {
			return nil, nil, err
		}

		return priv, elliptic.Marshal(curve, x, y), nil
	}

	// Generate a random salt for the encryption. Overridable for testing.
	randomSalt = func() ([]byte, error) {
		salt := make([]byte, 16)
		_, err := rand.Read(salt)
		if err != nil {
			return nil, err
		}
		return salt, nil
	}
)

// NewWebpushEncryption creates a new encryption context for sending, based on the subscription pub key and auth.
func NewWebpushEncryption(uapub, auth []byte) *WebpushEncryption {
	return &WebpushEncryption{
		Auth:     auth,
		UAPublic: uapub,
	}
}

func RawKeyToPrivateKey(key, pub string) *ecdsa.PrivateKey {
	publicUncomp, _ := base64.RawURLEncoding.DecodeString(pub)
	privateUncomp, _ := base64.RawURLEncoding.DecodeString(key)

	//curve := elliptic.P256()
	// TODO: privateUncomp may be DER ?
	x, y := elliptic.Unmarshal(curve, publicUncomp)
	d := new(big.Int).SetBytes(privateUncomp)

	pubkey := ecdsa.PublicKey{Curve: curve, X: x, Y: y}
	pkey := ecdsa.PrivateKey{PublicKey: pubkey, D: d}

	//if debugEncrypt {
	//	expectedX, expectedY := curve.ScalarBaseMult(d.Bytes())
	//	if x.Cmp(expectedX) != 0 || y.Cmp(expectedY) != 0 {
	//		fmt.Println("The private key D does not correspond to the point (X, Y).")
	//	}
	//
	//	pkey.Public()
	//}
	return &pkey
}

// NewWebpushDecryption creates a context for decrypting message by a UA.
// The private key is base64URL encoded.
//
func NewWebpushDecryption(uapriv string, uapub, auth []byte) *WebpushEncryption {

	uaprivb, _ := base64.RawURLEncoding.DecodeString(uapriv)
	//log.Println("XXXX " + base64.URLEncoding)
	return &WebpushEncryption{
		Auth:      auth,
		UAPublic:  uapub,
		UAPrivate: uaprivb,
	}
}

var debugEncrypt = false

// Encrypt a message such that it can be sent using the Web Push protocol.
//
// RFC8030 - message
// RFC8291 - encryption
func (er *WebpushEncryption) Encrypt(plaintext []byte) ([]byte, error) {
	var err error
	if er.Salt == nil {
		er.Salt, err = randomSalt()
	}
	if er.SendPublic == nil {
		er.SendPrivate, er.SendPublic, err = randomKey()
	}

	ua_pubkey := er.UAPublic
	auth := er.Auth
	serverPrivateKey := er.SendPrivate
	serverPublicKey := er.SendPublic

	if len(plaintext) > maxPayloadLength {
		return nil, fmt.Errorf("payload is too large. The max number of bytes is %d, input is %d bytes ", maxPayloadLength, len(plaintext))
	}

	if len(ua_pubkey) == 0 {
		return nil, fmt.Errorf("subscription must include the client's public key")
	}

	if len(auth) == 0 {
		return nil, fmt.Errorf("subscription must include the client's auth value")
	}

	// Use ECDH to derive a shared secret between us and the client. We generate
	// a fresh private/public key pair at random every time we encrypt.
	secret, err := sharedSecret(curve, ua_pubkey, serverPrivateKey, serverPublicKey)
	if err != nil {
		return nil, err
	}
	er.ecdh_secret = secret
	if debugEncrypt {
		log.Println("send_pub", base64.RawURLEncoding.EncodeToString(serverPublicKey))
		log.Println("send_priv", base64.RawURLEncoding.EncodeToString(serverPrivateKey))
		log.Println("ua_pub", base64.RawURLEncoding.EncodeToString(er.UAPublic))
		log.Println("ecdh_secret", base64.RawURLEncoding.EncodeToString(secret))
	}

	var key_info []byte
	key_info = append(key_info, []byte("WebPush: info")...)
	key_info = append(key_info, 0)
	key_info = append(key_info, ua_pubkey...)
	key_info = append(key_info, serverPublicKey...)
	if debugEncrypt {
		log.Println("key_info", base64.RawURLEncoding.EncodeToString(key_info))
	}
	// Derive a Pseudo-Random Key (prk) that can be used to further derive our
	// other encryption parameters. These derivations are described in
	// https://tools.ietf.org/html/draft-ietf-httpbis-encryption-encoding-00
	ikm := hkdf(auth, secret, key_info, 32)
	if debugEncrypt {
		log.Println("ikm", base64.RawURLEncoding.EncodeToString(ikm))
	}

	// Derive the Content Encryption Key and nonce
	ctx := newContext(ua_pubkey, serverPublicKey)
	cek := newCEK128(ctx, er.Salt, ikm)
	if debugEncrypt {
		log.Println("cek", base64.RawURLEncoding.EncodeToString(cek))
	}
	nonce := newNonce128(ctx, er.Salt, ikm)
	if debugEncrypt {
		log.Println("nonce", base64.RawURLEncoding.EncodeToString(nonce))
	}
	// Do the actual encryption
	pt := plaintext
	pt = append(pt, 2)
	if debugEncrypt {
		log.Println("pt_pad", base64.RawURLEncoding.EncodeToString(pt))
	}

	ciphertext, err := encrypt128(pt, cek, nonce)
	if debugEncrypt {
		log.Println("cipher", base64.RawURLEncoding.EncodeToString(ciphertext))
	}
	if err != nil {
		return nil, err
	}

	res := er.Salt
	res = append(res, 0, 0, 16, 0, 65)
	res = append(res, er.SendPublic...)

	if debugEncrypt {
		log.Println("header ", base64.RawURLEncoding.EncodeToString(res))
	}
	res = append(res, ciphertext...)

	er.Ciphertext = res
	// Return all of the values needed to construct a Web Push HTTP request.
	return res, nil
}

func (er *WebpushEncryption) Decrypt(cypher []byte) ([]byte, error) {
	er.Ciphertext = cypher
	salt := er.Ciphertext[0:16]
	serverPublicKey := er.Ciphertext[21 : 21+65]
	ua_pubkey := er.UAPublic
	auth := er.Auth

	// Use ECDH to derive a shared secret between us and the client. We generate
	// a fresh private/public key pair at random every time we encrypt.
	secret, err := sharedSecret(curve, serverPublicKey, er.UAPrivate, er.UAPublic)
	if err != nil {
		return nil, err
	}
	if debugEncrypt {
		log.Println("send_pub", base64.RawURLEncoding.EncodeToString(serverPublicKey))
		log.Println("ua_pub", base64.RawURLEncoding.EncodeToString(er.UAPublic))
		log.Println("ua_priv", base64.RawURLEncoding.EncodeToString(er.UAPrivate))
		log.Println("ecdh_secret", base64.RawURLEncoding.EncodeToString(secret))
	}

	var key_info []byte
	key_info = append(key_info, []byte("WebPush: info")...)
	key_info = append(key_info, 0)
	key_info = append(key_info, ua_pubkey...)
	key_info = append(key_info, serverPublicKey...)
	if debugEncrypt {
		log.Println("key_info", base64.RawURLEncoding.EncodeToString(key_info))
	}
	// Derive a Pseudo-Random Key (prk) that can be used to further derive our
	// other encryption parameters. These derivations are described in
	// https://tools.ietf.org/html/draft-ietf-httpbis-encryption-encoding-00
	ikm := hkdf(auth, secret, key_info, 32)
	if debugEncrypt {
		log.Println("ikm", base64.RawURLEncoding.EncodeToString(ikm))
	}

	// Derive the Content Encryption Key and nonce
	ctx := newContext(ua_pubkey, serverPublicKey)
	cek := newCEK128(ctx, salt, ikm)
	if debugEncrypt {
		log.Println("cek", base64.RawURLEncoding.EncodeToString(cek))
	}
	nonce := newNonce128(ctx, salt, ikm)
	if debugEncrypt {
		log.Println("nonce", base64.RawURLEncoding.EncodeToString(nonce))
	}

	plain, err := decrypt128(er.Ciphertext[21+65:], cek, nonce)
	if err != nil {
		return nil, err
	}

	return plain[0 : len(plain)-1], nil
}

func newInfo128(infoType string, context []byte) []byte {
	var info []byte
	info = append(info, []byte("Content-Encoding: ")...)
	info = append(info, []byte(infoType)...)
	info = append(info, 0)
	//info = append(info, []byte("P-256")...)
	//info = append(info, context...)
	return info
}

func newCEK128(ctx, salt, prk []byte) []byte {
	info := newInfo128("aes128gcm", ctx)
	if debugEncrypt {
		log.Println("cek_info", base64.RawURLEncoding.EncodeToString(info))
	}
	return hkdf(salt, prk, info, 16)
}

func newNonce128(ctx, salt, prk []byte) []byte {
	info := newInfo128("nonce", ctx)
	if debugEncrypt {
		log.Println("nonce_info", base64.RawURLEncoding.EncodeToString(info))
	}
	return hkdf(salt, prk, info, 12)
}

// Creates a context for deriving encyption parameters, as described in
// https://tools.ietf.org/html/draft-ietf-httpbis-encryption-encoding-00.
// The 'context' in this case is just the public keys of both client and server.
// The keys should always be 65 bytes each. The format of the keys is
// described in section 4.3.6 of the (sadly not freely linkable) ANSI X9.62
// specification.
func newContext(clientPublicKey, serverPublicKey []byte) []byte {
	// The context format is:
	// 0x00 || length(clientPublicKey) || clientPublicKey ||
	//         length(serverPublicKey) || serverPublicKey
	// The lengths are 16-bit, Big Endian, unsigned integers so take 2 bytes each.
	cplen := uint16(len(clientPublicKey))
	cplenbuf := make([]byte, 2)
	binary.BigEndian.PutUint16(cplenbuf, cplen)

	splen := uint16(len(serverPublicKey))
	splenbuf := make([]byte, 2)
	binary.BigEndian.PutUint16(splenbuf, splen)

	var ctx []byte
	ctx = append(ctx, 0)
	ctx = append(ctx, cplenbuf...)
	ctx = append(ctx, []byte(clientPublicKey)...)
	ctx = append(ctx, splenbuf...)
	ctx = append(ctx, []byte(serverPublicKey)...)

	return ctx
}

// HMAC-based Extract-and-Expand Key Derivation Function (HKDF)
//
// This is used to derive a secure encryption key from a mostly-secure shared
// secret.
//
// This is a partial implementation of HKDF tailored to our specific purposes.
// In particular, for us the value of N will always be 1, and thus T always
// equals HMAC-Hash(PRK, info | 0x01). This is true because the maximum output
// length we need/allow is 32.
//
// See https://www.rfc-editor.org/rfc/rfc5869.txt
func hkdf(salt, ikm, info []byte, length int) []byte {
	// HMAC length for SHA256 is 32 bytes, so that is the maximum result length.
	if length > 32 {
		panic("Can only produce HKDF outputs up to 32 bytes long")
	}

	// Extract
	mac := hmac.New(sha256.New, salt)
	mac.Write(ikm)
	prk := mac.Sum(nil)

	// Expand
	mac = hmac.New(sha256.New, prk)
	mac.Write(info)
	mac.Write([]byte{1})
	return mac.Sum(nil)[0:length]
}

// Encrypt the plaintext message using AES128/GCM
func encrypt128(plaintext, key, nonce []byte) ([]byte, error) {
	// StartListener padding. There is a uint16 size followed by that number of bytes of
	// padding.
	// TODO: Right now we leave the size at zero. We should add a padding option
	// that allows the payload size to be obscured.
	//padding := make([]byte, 2)
	//data := append(padding, plaintext...)

	c, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}
	gcm, err := cipher.NewGCM(c)
	if err != nil {
		return nil, err
	}

	// TODO: to reduce allocations, allow out buffer to be passed in
	// (all temp buffers can be kept in a context, size is bound)
	return gcm.Seal([]byte{}, nonce, plaintext, nil), nil
}

// Decrypt the message using AES128/GCM
func decrypt128(ciphertext, key, nonce []byte) (plaintext []byte, err error) {
	c, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}
	gcm, err := cipher.NewGCM(c)
	if err != nil {
		return nil, err
	}

	plaintext, err = gcm.Open([]byte{}, nonce, ciphertext, nil)
	return
}

// Given the coordinates of a party A's public key and the bytes of party B's
// private key, compute a shared secret.
func sharedSecret(curve elliptic.Curve, pub, priv []byte, privPub []byte) ([]byte, error) {
	//ecdh.P256().UnmarshalPublicKey(pub)

	publicX := new(big.Int).SetBytes(pub[1 : 1+32])
	publicY := new(big.Int).SetBytes(pub[1+32:])

	//, publicY := elliptic.Unmarshal(curve, pub)

	//pubk := ecdsa.PublicKey{Curve: curve, X: publicX, Y: publicY}
	//pubkecdh, _ := pubk.ECDH()
	//
	//ppublicX, ppublicY := elliptic.Unmarshal(curve, privPub)
	//privk2 := ecdsa.PublicKey{
	//	Curve: curve,
	//	X:     ppublicX,
	//	Y:     ppublicY,
	//}
	//privk := ecdsa.PrivateKey{
	//	D: new(big.Int).SetBytes(priv),
	//	PublicKey: privk2,
	//}
	//privkec, _ := privk.ECDH()
	//bb, _ := privkec.ECDH(pubkecdh)

	//if publicX == nil {
	//	return nil, fmt.Errorf("Couldn't unmarshal public key. Not a valid point on the curve.")
	//}

	// Need the public key associated with priv

	x, _ := curve.ScalarMult(publicX, publicY, priv)

	//if !bytes.Equal(x.Bytes(), bb) {
	//	log.Println("XXXXX NOT MATCH")
	//	return bb, nil
	//}
	return x.Bytes(), nil
}

// Send an encrypted message to a node.
func  SendMessage(hc *http.Client, subs string, show bool, msg string, v TokenProvider) {
	var err error
	if msg == "" {
		msgB, err := ioutil.ReadAll(os.Stdin)
		if err != nil {
			fmt.Println("Failed to read message")
			os.Exit(3)
		}
		msg = string(msgB)
	}

	destURL := ""
	var destPubK []byte
	var authk []byte

	if subs != "" {
		to, err := SubscriptionFromJSON([]byte(subs))
		if err != nil {
			fmt.Println("Invalid endpoint "+flag.Arg(1), err)
			os.Exit(3)
		}
		destURL = to.Endpoint
		destPubK = to.Key
		authk = to.Auth
		if len(authk) == 0 {
			authk = []byte{1}
		}
	}

	ec := NewWebpushEncryption(destPubK, authk)
	c, _ := ec.Encrypt([]byte(msg))

	ah, _ := v.GetToken(context.Background(), destURL)

	if show {
		payload64 := base64.StdEncoding.EncodeToString(c)
		cmd := "echo -n " + payload64 + " | base64 -d > /tmp/$$.bin; curl -XPOST --data-binary @/tmp/$$.bin"
		cmd += " -proxy 127.0.0.1:5224"
		cmd += " -Httl:0"
		cmd += " -H\"authorization:" + ah + "\""
		fmt.Println(cmd + " " + destURL)

		return
	}

	req, _ := http.NewRequest("POST", destURL, bytes.NewBuffer(c))
	req.Header.Add("ttl", "0")
	req.Header.Add("authorization", ah)
	req.Header.Add("Content-Encoding", "aes128gcm")

	res, err := hc.Do(req)

	if res == nil {
		fmt.Println("Failed to send ", err)

	} else if err != nil {
		fmt.Println("Failed to send ", err)

	} else if res.StatusCode != 201 {
		//dmpReq, err := httputil.DumpRequest(req, true)
		//fmt.Printf(string(dmpReq))
		dmp, _ := httputil.DumpResponse(res, true)
		fmt.Println(string(dmp))
		fmt.Println("Failed to send ", err, res.StatusCode)

		//} else if *verbose {
		//	dmpReq, _ := httputil.DumpRequest(req, true)
		//	fmt.Printf(string(dmpReq))
		//	dmp, _ := httputil.DumpResponse(res, true)
		//	fmt.Printf(string(dmp))
	}
}

// Subscription holds the useful values from a PushSubscription object acquired
// from the browser.
//
// https://w3c.github.io/push-api/
//
// Returned as result of /subscribe
func SubscriptionFromJSON(b []byte) (*Subscription, error) {
	sub := &Subscription{}
	if err := json.Unmarshal(b, &sub); err != nil {
		return nil, err
	}



	return sub, nil
}


// Subscription holds the values for encrypting messages
type Subscription struct {
	// Endpoint is the URL to send the Web Push message to. Comes from the
	// endpoint field of the PushSubscription.
	Endpoint string `json:"endpoint"`

	Keys struct {
		P256dh string `json:"p256Dh"`
		Auth string `json:"auth"`
	} `json:"keys"`

	// Key is the client's public key. From the getKey("p256dh") or keys.p256dh field.
	Key []byte `json:"-"`

	// Auth is a value used by the client to validate the encryption. From the
	// keys.auth field.
	// The encrypted aes128gcm will have 16 bytes authentication tag derived from this.
	// This is the pre-shared authentication secret.
	Auth []byte `json:"-"`

	// Used by the UA to receive messages, as PUSH promises
	Location string `json:"-"`
}

func (s *Subscription) Encrypt(data []byte) []byte {

	if s.Key == nil {
		b64 := base64.URLEncoding.WithPadding(base64.NoPadding)

		// Chrome < 52 incorrectly adds padding when Base64 encoding the values, so
		// we need to strip that out
		key, err := b64.DecodeString(strings.TrimRight(s.Keys.P256dh, "="))
		if err != nil {
			return nil
		}
		s.Key = key

		auth, err := b64.DecodeString(strings.TrimRight(s.Keys.Auth, "="))
		if err != nil {
			return nil
		}
		s.Auth = auth
	}

	we := &WebpushEncryption{
		Auth: s.Auth,
		UAPublic: s.Key,
	}
	rs, _ := we.Encrypt(data)
	return rs
}

type TokenProvider interface {
	GetToken(context.Context, string) (string, error)
}

// NewVapidRequest creates a valid Web Push HTTP request for sending a message
// to a subscriber, using Vapid authentication.
//
// You can add more headers to configure collapsing, TTL.
func NewRequest(dest string, key, authK []byte,
		message string, ttlSec int, v TokenProvider) (*http.Request, error) {

	// If the endpoint is GCM then we temporarily need to rewrite it, as not all
	// GCM servers support the Web Push protocol. This should go away in the
	// future.
	req, err := http.NewRequest("POST", dest, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Add("ttl", strconv.Itoa(ttlSec))

	if v != nil {
		tok, _ := v.GetToken(req.Context(), dest)
		if !strings.Contains(tok, " ") {
			tok = "Bearer " + tok
		}
		req.Header.Add("authorization", tok)
	}

	// If there is no payload then we don't actually need encryption
	if message != "" {
		ec := NewWebpushEncryption(key, authK)
		payload, err := ec.Encrypt([]byte(message))
		if err != nil {
			return nil, err
		}
		req.Body = ioutil.NopCloser(bytes.NewReader(payload))
		req.ContentLength = int64(len(payload))
		req.Header.Add("encryption",
			headerField("salt", ec.Salt))
		keys := headerField("dh", ec.SendPublic)
		req.Header.Add("crypto-key", keys)
		req.Header.Add("content-encoding", "aesgcm")
	}

	return req, nil
}

// A helper for creating the value part of the HTTP encryption headers
func headerField(headerType string, value []byte) string {
	return fmt.Sprintf(`%s=%s`, headerType, base64.RawURLEncoding.EncodeToString(value))
}
